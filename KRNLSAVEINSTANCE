-- SaveInstance Fixed
-- Version 0866-Fixed
-- December 13, 2025

local SaveInstance = {}

SaveInstance.BufferSize = 5632
SaveInstance.DecompileScripts = false
SaveInstance.SaveRemovedInstances = true
SaveInstance.SavePlayer = true

SaveInstance._scriptCache = {}

local encodeBase64 = crypt and crypt.base64encode or function() return "" end
local gethiddenproperty = gethiddenproperty or error

-- Ignore list to skip Core services
local IGNORE_LIST = {} do
    local function Ignore(...)
        for _,instance in ipairs(table.pack(...)) do
            if not instance then continue end
            IGNORE_LIST[instance] = true
        end
    end

    Ignore(
        game:GetService("CoreGui"),
        game:GetService("CorePackages"),
        game:GetService("Players")
    )

    coroutine.wrap(function()
        local chat = game:GetService("Chat")
        Ignore(
            chat:WaitForChild("ChatModules"),
            chat:WaitForChild("ClientChatModules"),
            chat:WaitForChild("ChatServiceRunner"),
            chat:WaitForChild("ChatScript")
        )
    end)()
end

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- Load API dump
local ApiDump do
    local version = game:HttpGetAsync("http://setup.roblox.com/versionQTStudio")
    local apiDumpJSON = game:HttpGetAsync("http://setup.roblox.com/" .. version .. "-API-Dump.json")
    ApiDump = HttpService:JSONDecode(apiDumpJSON)
end

-- Prepare Classes table
local Classes = {} do
    for _,class in ipairs(ApiDump.Classes) do
        class.Properties = {}
        for _,member in ipairs(class.Members) do
            if member.MemberType == "Property" and member.Serialization.CanSave then
                table.insert(class.Properties, member)
            end
        end
        Classes[class.Name] = class
    end

    -- Inherit properties
    for _,class in ipairs(ApiDump.Classes) do
        if Classes[class.Superclass] then
            for _,prop in ipairs(Classes[class.Superclass].Properties) do
                table.insert(class.Properties, prop)
            end
        end
    end
end

-- Escape XML special characters
function SaveInstance.EscapeForm(str)
    local entityMap = { ["<"]="lt", [">"]="gt", ["&"]="amp", ["\""]="quot", ["'"]="apos" }
    return str:gsub("[><&\"']", function(s) return "&"..entityMap[s]..";" end)
end

-- Cache scripts if needed
function SaveInstance.CacheScripts(parent)
    if not SaveInstance.DecompileScripts then return end
    assert(typeof(parent) == "Instance", "Argument #1 'parent' must be an Instance")

    local jobCount = 0
    local function Cache(instance)
        if IGNORE_LIST[instance] then return end
        if instance:IsA("LocalScript") or instance:IsA("ModuleScript") then
            jobCount += 1
            spawn(function()
                local ok, result = pcall(decompile, instance)
                if ok then SaveInstance._scriptCache[instance] = result end
                jobCount -= 1
            end)
        end
        for _,child in ipairs(instance:GetChildren()) do
            Cache(child)
        end
    end

    Cache(parent)
    while jobCount > 0 do RunService.Heartbeat:Wait() end
end

-- Name mapping for humanoid parts
local NameMap = {
    ["MeshPart"] = {
        ["LeftUpperArm"] = "LeftArm",
        ["RightUpperArm"] = "RightArm",
        ["LeftLowerLeg"] = "LeftLeg",
        ["RightLowerLeg"] = "RightLeg",
        ["UpperTorso"] = "Torso",
        ["LowerTorso"] = "HumanoidRootPart"
    }
}

-- Convert Unions â†’ MeshParts safely
local function ConvertUnionToMesh(instance)
    if not instance:IsA("UnionOperation") then return instance end

    local meshPart = Instance.new("MeshPart")
    meshPart.Name = instance.Name
    meshPart.Size = instance.Size
    meshPart.CFrame = instance.CFrame
    meshPart.BrickColor = instance.BrickColor
    meshPart.Material = instance.Material
    meshPart.Parent = instance.Parent

    instance:Destroy()
    return meshPart
end

-- Main Save function
function SaveInstance.Save(parent)
    parent = parent or game

    local file = parent:GetFullName() .. "-Save-" .. game.PlaceId
    if parent.Parent == game or parent == game then
        file ..= ".rbxlx"
    else
        file ..= ".rbxmx"
    end

    local buffer = {}
    local bufferSize = 0
    local instanceIds = {}
    local instanceCount = 0

    local function Flush()
        appendfile(file, table.concat(buffer))
        table.clear(buffer)
        bufferSize = 0
    end

    local function Insert(entry)
        bufferSize += 1
        buffer[bufferSize] = entry
    end

    local function Identify(instance)
        if instanceIds[instance] then return instanceIds[instance] end
        instanceCount += 1
        instanceIds[instance] = "RBX"..instanceCount
        return "RBX"..instanceCount
    end

    local function Serialize(instance, children)
        if instance == game then return end
        instance = ConvertUnionToMesh(instance)

        if bufferSize > SaveInstance.BufferSize then Flush() end

        local className = instance.ClassName
        if className == "PlayerScripts" or className == "PlayerGui" then
            className = "Folder"
        end

        local serializedName = NameMap[className] and NameMap[className][instance.Name] or instance.Name

        Insert("<Item class=\""..className.."\" referent=\""..Identify(instance).."\">\n<Properties>")

        for _,property in ipairs(Classes[instance.ClassName] and Classes[instance.ClassName].Properties or {}) do
            local propertyType = property.ValueType.Name
            local propertyCategory = property.ValueType.Category
            local success, value = pcall(function() return instance[property.Name] end)
            if not success then
                success, value = pcall(gethiddenproperty, instance, property.Name)
                if not success then continue end
            end

            local propertyName = property.SerializedName or property.Name

            if propertyCategory == "Class" then
                Insert("<Ref name=\""..propertyName.."\">"..(value and Identify(value) or "null").."</Ref>")

            elseif propertyType == "CFrame" then
                local x,y,z,r00,r01,r02,r10,r11,r12,r20,r21,r22 = value:GetComponents()
                Insert("<CoordinateFrame name=\""..propertyName.."\"><X>"..x.."</X><Y>"..y.."</Y><Z>"..z.."</Z><R00>"..r00.."</R00><R01>"..r01.."</R01><R02>"..r02.."</R02><R10>"..r10.."</R10><R11>"..r11.."</R11><R12>"..r12.."</R12><R20>"..r20.."</R20><R21>"..r21.."</R21><R22>"..r22.."</R22></CoordinateFrame>")

            elseif propertyType == "Vector3" then
                Insert("<Vector3 name=\""..propertyName.."\"><X>"..value.X.."</X><Y>"..value.Y.."</Y><Z>"..value.Z.."</Z></Vector3>")

            elseif propertyType == "Vector2" then
                Insert("<Vector2 name=\""..propertyName.."\"><X>"..value.X.."</X><Y>"..value.Y.."</Y></Vector2>")

            elseif propertyType == "Color3" then
                Insert("<Color3 name=\""..propertyName.."\"><R>"..value.R.."</R><G>"..value.G.."</G><B>"..value.B.."</B></Color3>")

            elseif propertyType == "UDim" then
                Insert("<UDim name=\""..propertyName.."\"><S>"..value.Scale.."</S><O>"..value.Offset.."</O></UDim>")

            elseif propertyType == "UDim2" then
                Insert("<UDim2 name=\""..propertyName.."\"><XS>"..value.X.Scale.."</XS><XO>"..value.X.Offset.."</XO><YS>"..value.Y.Scale.."</YS><YO>"..value.Y.Offset.."</YO></UDim2>")

            elseif propertyType == "BinaryString" then
                if typeof(value) == "string" then
                    Insert("<BinaryString name=\""..propertyName.."><![CDATA["..encodeBase64(value).."]]></BinaryString>")
                else
                    warn("[SaveInstance] Skipped BinaryString: "..instance:GetFullName().."."..propertyName.." not a string")
                end

            elseif propertyType == "ProtectedString" then
                Insert("<ProtectedString name=\""..propertyName.."><![CDATA["..(SaveInstance._scriptCache[instance] or value).."]]></ProtectedString>")

            elseif propertyCategory == "Enum" then
                Insert("<token name=\""..propertyName.."\">"..value.Value.."</token>")

            else
                Insert("<"..type(value).." name=\""..propertyName.."\">"..SaveInstance.EscapeForm(tostring(value)).."</"..type(value)..">")
            end
        end

        Insert("</Properties>")

        for _,child in ipairs(children or instance:GetChildren()) do
            Serialize(child)
        end

        Insert("</Item>")
    end

    SaveInstance.CacheScripts(parent)

    writefile(file, "<roblox xmlns:xmime=\"http://www.w3.org/2005/05/xmlmime\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://www.roblox.com/roblox.xsd\" version=\"4\">\n<External>null</External>\n<External>nil</External>")

    if parent == game then
        for _,service in ipairs(game:GetChildren()) do
            if IGNORE_LIST[service] then continue end
            Serialize(service)
        end
    else
        Serialize(parent)
    end

    if SaveInstance.SaveRemovedInstances then
        local removedFolder = Instance.new("Folder")
        removedFolder.Name = "RemovedInstances"
        Serialize(removedFolder, getnilinstances())
    end

    if SaveInstance.SavePlayer then
        local player = game:GetService("Players").LocalPlayer
        local playerFolder = Instance.new("Folder")
        playerFolder.Name = "LocalPlayer"
        SaveInstance.CacheScripts(player)
        Serialize(playerFolder, player:GetChildren())
    end

    Insert("<SharedStrings>\n</SharedStrings>\n</roblox>")
    Flush()
    print("[SaveInstance] Save complete: "..file)
end

return SaveInstance
